class SDL2;

external classtype;

use Color8:      { color, white, black };
use String:      { string };
use World:       { TheWorld };
use ArrayArith:  { +, -, *, /, !=, all };
use ArrayBasics: { shape, sel, modarray };

export all;

external SDL2 initDisplay( int[2] shp);
    #pragma effect   TheWorld
    #pragma linkname "SAC_SDL2_display"
    #pragma linkobj  "src/SDL2/data.o"
    #pragma linkobj  "src/SDL2/display.o"
    #pragma linkobj  "src/SDL2/event.o"
    #pragma linkobj  "src/SDL2/init.o"
    #pragma linkobj  "src/SDL2/invert.o"
    #pragma linkobj  "src/SDL2/mouse.o"
    #pragma linkobj  "src/SDL2/names.o"
    #pragma linkobj  "src/SDL2/sem.o"
    #pragma linkobj  "src/SDL2/setup.o"
    #pragma linkobj  "src/SDL2/title.o"
    #pragma linkobj  "src/SDL2/update.o"
    #pragma linkwith "SDL"
    #pragma linkwith "pthread"
    #pragma linkwith "rt"
    #pragma refcounting [1]
    /*
     * Open a new display window on screen.
     * The parameter 'shp' gives the Width/Height dimensions.
     */

inline SDL2 initDisplay( int[2] shp, bool async)
{
  d = initDisplay( shp);
  return( d);
}
    /*
     * Backward compatibility: Open a new display.
     * The parameter 'async' is ignored.
     */

SDL2 initMultiDisplay( int[2] layout, int[2] disp_shp)
{
  size = layout * disp_shp + (layout - 1) * 3;
  res = initDisplay( size, true);
  frame = with {
            ( . <= iv <= . step (disp_shp + 3) width disp_shp) : black();
          } : genarray( size, white());
  drawArray( res, frame);
  return( res);
}
    /*
     * Open a new display and divide the window into identical subsections.
     * The parameter 'layout' gives the number and relative position
     * of the subsections. The parameter 'disp_shp' gives the 
     * Width/Height dimensions of one subsection.
     */

external void resizeDisplay( SDL2& disp, int[2] shp);
    #pragma effect   TheWorld
    #pragma linkname "SAC_SDL2_resize"
    #pragma linkobj  "src/SDL2/display.o"
    #pragma refcounting [1]
    /*
     * Resize an existing display window on screen.
     * The parameter 'shp' gives the desired Width/Height dimensions.
     */

external void destroyDisplay( SDL2& disp);
    #pragma effect   TheWorld
    #pragma linkname "SAC_SDL2_close"
    #pragma linkobj  "src/SDL2/close.o"
    /*
     * Close an existing display window and free all resources.
     */

external void drawArray( SDL2& disp, color[.,.] array);
    #pragma effect   TheWorld
    #pragma linkname "SAC_SDL2_draw"
    #pragma linkobj  "src/SDL2/draw.o"
    #pragma refcounting [1]
    /*
     * Copy an array to a display window.
     * These must have identical dimensions.
     */


void drawArrayMulti( SDL2& disp, color[.,.] array, int[2] pos)
{
  drawArrayOffset( disp, array, (Color8::shape( array) + 3) * pos);
}
    /*
     * Copy an array to a given subsection of a multi-display.
     */

external void drawArrayOffset( SDL2& disp, 
                               color[.,.] array, int[2] offset);
    #pragma linkname "SAC_SDL2_draw2"
    #pragma linkobj  "src/SDL2/draw.o"
    #pragma linkwith "SDL"
    #pragma refcounting [1]
    /*
     * Change the color value of a single pixel in the pixel buffer.
     */

external int[2] getExtent( SDL2 &disp);
    #pragma linkname "SAC_SDL2_extent"
    #pragma linkobj  "src/SDL2/extent.o"
    #pragma linkwith "SDL"
    #pragma linksign [1,2]
    /*
     * Request the Width/Height dimensions of a display window.
     */

external void drawPixel( SDL2 &disp, int[2] idx, color val);
    #pragma linkname "SAC_SDL2_pixel"
    #pragma linkobj  "src/SDL2/pixel.o"
    #pragma linkwith "SDL"
    #pragma refcounting [1,2]
    /*
     * Change the color value of a single pixel in the pixel buffer.
     */

external void invertRect( SDL2& disp, int[2] offset, int[2] size);
    #pragma linkname "SAC_SDL2_invert2"
    #pragma linkobj  "src/SDL2/invert.o"
    #pragma linkwith "SDL"
    #pragma linksign [1,2,3]
    /*
     * Invert a rectangle on screen:
     *   - offset gives the X/Y position
     *   - size the Width/Height of the rectangle.
     */

external void updateDisp( SDL2& disp, bool async);
    #pragma linkname "SAC_SDL2_update"
    #pragma linkobj  "src/SDL2/update.o"
    #pragma linkwith "SDL"
    #pragma linksign [1,2]
    /*
     * Update the display window. This copies the pixel buffer to screen.
     * Use this function in combination with drawPixel.
     *    - When async is false the function waits for completion.
     *    - When async is true the function generates an update request
     *      and immediately returns. Use with caution. Give the system
     *      an appropriate amount of time to complete the request before
     *      generating another update request. Note that this may interfere
     *      with subsequent draw operations.
     */

external void updateRect( SDL2& disp, int[2] offset, int[2] size, bool async);
    #pragma linkname "SAC_SDL2_update2"
    #pragma linkobj  "src/SDL2/update.o"
    #pragma linkwith "SDL"
    #pragma linksign [1,2,3,4]
    /*
     * Update a rectangle in the display window similar to updateDisp:
     *   - offset gives the X/Y position
     *   - size the Width/Height of the rectangle.
     */

external int[2,2] getSelection( SDL2 &disp);
    #pragma linkname "SAC_SDL2_select"
    #pragma linkobj  "src/SDL2/select.o"
    #pragma linkwith "SDL"
    #pragma linksign [1,2]
    /*
     * Ask the user to select an area in the display window using
     * the left mouse button. The middle mouse button cancels.
     */

int[2], int[2,2] getSelectionMulti( SDL2 &disp, int[2] layout)
{
  selection = getSelection( disp);
  extent = getExtent( disp);
  shape = (extent - 3 * (layout - 1)) / layout;

  field = { [i] -> selection[[i]] / (shape + 3)};
  pos = { [i] -> selection[[i]] - 3 * field[[i]] - field[[i]] * shape};

  if (all( field[[0]] != field[[1]])) {
    pos[[1]] = shape - 1;
  } 

  return( field[[0]], pos);
}
    /*
     * Ask the user to select an area in any of the subsections
     * of a multi-window using the left mouse button.
     * The middle mouse button cancels.
     */

external void fullscreen( bool enable);
    #pragma effect   TheWorld
    #pragma linkname "SAC_SDL2_enable_fullscreen"
    #pragma linkobj  "src/SDL2/display.o"
    /*
     * Create display windows fullscreen. Please note
     * that this may change the system X11 video mode.
     */

external void noframe( bool enable);
    #pragma effect   TheWorld
    #pragma linkname "SAC_SDL2_enable_noframe"
    #pragma linkobj  "src/SDL2/display.o"
    /*
     * Create display windows without a window manager frame.
     */

external void cursor( bool enable);
    #pragma effect   TheWorld
    #pragma linkname "SAC_SDL2_cursor"
    #pragma linkobj  "src/SDL2/title.o"
    /*
     * Enable or disable the mouse cursor in the application display window.
     */

external void heading( string heading);
    #pragma effect   TheWorld
    #pragma linkname "SAC_SDL2_heading"
    #pragma linkobj  "src/SDL2/title.o"
    /*
     * Change the window manager frame header. This may trigger an old bug
     * in libX11 under certain circumstances and crash or deadlock.
     * The function getSelection also uses this function.
     */

external SDL2 nullDisplay();
    #pragma effect   TheWorld
    #pragma linkname "SAC_SDL2_null"
    #pragma linkobj  "src/SDL2/data.o"
    #pragma linksign [0]
    /*
     * Return a NULL display as a placeholder.
     */

external bool isNullDisplay( SDL2& disp);
    #pragma effect   TheWorld
    #pragma linkname "SAC_SDL2_isnull"
    #pragma linkobj  "src/SDL2/data.o"
    #pragma linksign [0,1]
    /*
     * Test if a display is a NULL display.
     */

